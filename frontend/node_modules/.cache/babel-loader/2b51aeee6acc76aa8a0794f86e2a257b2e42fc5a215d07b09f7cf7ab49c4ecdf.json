{"ast":null,"code":"/*!\n * CSSJanus. https://github.com/cssjanus/cssjanus\n *\n * Copyright 2014 Trevor Parscal\n * Copyright 2010 Roan Kattouw\n * Copyright 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar cssjanus;\n\n/**\n * Create a tokenizer object.\n *\n * This utility class is used by CSSJanus to protect strings by replacing them temporarily with\n * tokens and later transforming them back.\n *\n * @class\n * @constructor\n * @param {RegExp} regex Regular expression whose matches to replace by a token\n * @param {string} token Placeholder text\n */\nfunction Tokenizer(regex, token) {\n  var matches = [],\n    index = 0;\n\n  /**\n   * Add a match.\n   *\n   * @private\n   * @param {string} match Matched string\n   * @return {string} Token to leave in the matched string's place\n   */\n  function tokenizeCallback(match) {\n    matches.push(match);\n    return token;\n  }\n\n  /**\n   * Get a match.\n   *\n   * @private\n   * @return {string} Original matched string to restore\n   */\n  function detokenizeCallback() {\n    return matches[index++];\n  }\n  return {\n    /**\n     * Replace matching strings with tokens.\n     *\n     * @param {string} str String to tokenize\n     * @return {string} Tokenized string\n     */\n    tokenize: function (str) {\n      return str.replace(regex, tokenizeCallback);\n    },\n    /**\n     * Restores tokens to their original values.\n     *\n     * @param {string} str String previously run through tokenize()\n     * @return {string} Original string\n     */\n    detokenize: function (str) {\n      return str.replace(new RegExp('(' + token + ')', 'g'), detokenizeCallback);\n    }\n  };\n}\n\n/**\n * Create a CSSJanus object.\n *\n * CSSJanus transforms CSS rules with horizontal relevance so that a left-to-right stylesheet can\n * become a right-to-left stylesheet automatically. Processing can be bypassed for an entire rule\n * or a single property by adding a / * @noflip * / comment above the rule or property.\n *\n * @class\n * @constructor\n */\nfunction CSSJanus() {\n  var\n    // Tokens\n    temporaryToken = '`TMP`',\n    noFlipSingleToken = '`NOFLIP_SINGLE`',\n    noFlipClassToken = '`NOFLIP_CLASS`',\n    commentToken = '`COMMENT`',\n    // Patterns\n    nonAsciiPattern = '[^\\\\u0020-\\\\u007e]',\n    unicodePattern = '(?:(?:\\\\\\\\[0-9a-f]{1,6})(?:\\\\r\\\\n|\\\\s)?)',\n    numPattern = '(?:[0-9]*\\\\.[0-9]+|[0-9]+)',\n    unitPattern = '(?:em|ex|px|cm|mm|in|pt|pc|deg|rad|grad|ms|s|hz|khz|%)',\n    directionPattern = 'direction\\\\s*:\\\\s*',\n    urlSpecialCharsPattern = '[!#$%&*-~]',\n    validAfterUriCharsPattern = '[\\'\"]?\\\\s*',\n    nonLetterPattern = '(^|[^a-zA-Z])',\n    charsWithinSelectorPattern = '[^\\\\}]*?',\n    noFlipPattern = '\\\\/\\\\*\\\\!?\\\\s*@noflip\\\\s*\\\\*\\\\/',\n    commentPattern = '\\\\/\\\\*[^*]*\\\\*+([^\\\\/*][^*]*\\\\*+)*\\\\/',\n    escapePattern = '(?:' + unicodePattern + '|\\\\\\\\[^\\\\r\\\\n\\\\f0-9a-f])',\n    nmstartPattern = '(?:[_a-z]|' + nonAsciiPattern + '|' + escapePattern + ')',\n    nmcharPattern = '(?:[_a-z0-9-]|' + nonAsciiPattern + '|' + escapePattern + ')',\n    identPattern = '-?' + nmstartPattern + nmcharPattern + '*',\n    quantPattern = numPattern + '(?:\\\\s*' + unitPattern + '|' + identPattern + ')?',\n    signedQuantPattern = '((?:-?' + quantPattern + ')|(?:inherit|auto))',\n    fourNotationQuantPropsPattern = '((?:margin|padding|border-width)\\\\s*:\\\\s*)',\n    fourNotationColorPropsPattern = '((?:-color|border-style)\\\\s*:\\\\s*)',\n    colorPattern = '(#?' + nmcharPattern + '+|(?:rgba?|hsla?)\\\\([ \\\\d.,%-]+\\\\))',\n    // The use of a lazy match (\"*?\") may cause a backtrack limit to be exceeded before finding\n    // the intended match. This affects 'urlCharsPattern' and 'lookAheadNotOpenBracePattern'.\n    // We have not yet found this problem on Node.js, but we have on PHP 7, where it was\n    // mitigated by using a possessive quantifier (\"*+\"), which are not supported in JS.\n    // See <https://github.com/cssjanus/php-cssjanus/issues/14> and <https://phabricator.wikimedia.org/T215746#4944830>.\n    urlCharsPattern = '(?:' + urlSpecialCharsPattern + '|' + nonAsciiPattern + '|' + escapePattern + ')*?',\n    lookAheadNotLetterPattern = '(?![a-zA-Z])',\n    lookAheadNotOpenBracePattern = '(?!(' + nmcharPattern + '|\\\\r?\\\\n|\\\\s|#|\\\\:|\\\\.|\\\\,|\\\\+|>|~|\\\\(|\\\\)|\\\\[|\\\\]|=|\\\\*=|~=|\\\\^=|\\'[^\\']*\\'|\"[^\"]*\"|' + commentToken + ')*?{)',\n    lookAheadNotClosingParenPattern = '(?!' + urlCharsPattern + validAfterUriCharsPattern + '\\\\))',\n    lookAheadForClosingParenPattern = '(?=' + urlCharsPattern + validAfterUriCharsPattern + '\\\\))',\n    suffixPattern = '(\\\\s*(?:!important\\\\s*)?[;}])',\n    // Regular expressions\n    temporaryTokenRegExp = /`TMP`/g,\n    commentRegExp = new RegExp(commentPattern, 'gi'),\n    noFlipSingleRegExp = new RegExp('(' + noFlipPattern + lookAheadNotOpenBracePattern + '[^;}]+;?)', 'gi'),\n    noFlipClassRegExp = new RegExp('(' + noFlipPattern + charsWithinSelectorPattern + '})', 'gi'),\n    directionLtrRegExp = new RegExp('(' + directionPattern + ')ltr', 'gi'),\n    directionRtlRegExp = new RegExp('(' + directionPattern + ')rtl', 'gi'),\n    leftRegExp = new RegExp(nonLetterPattern + '(left)' + lookAheadNotLetterPattern + lookAheadNotClosingParenPattern + lookAheadNotOpenBracePattern, 'gi'),\n    rightRegExp = new RegExp(nonLetterPattern + '(right)' + lookAheadNotLetterPattern + lookAheadNotClosingParenPattern + lookAheadNotOpenBracePattern, 'gi'),\n    leftInUrlRegExp = new RegExp(nonLetterPattern + '(left)' + lookAheadForClosingParenPattern, 'gi'),\n    rightInUrlRegExp = new RegExp(nonLetterPattern + '(right)' + lookAheadForClosingParenPattern, 'gi'),\n    ltrInUrlRegExp = new RegExp(nonLetterPattern + '(ltr)' + lookAheadForClosingParenPattern, 'gi'),\n    rtlInUrlRegExp = new RegExp(nonLetterPattern + '(rtl)' + lookAheadForClosingParenPattern, 'gi'),\n    cursorEastRegExp = new RegExp(nonLetterPattern + '([ns]?)e-resize', 'gi'),\n    cursorWestRegExp = new RegExp(nonLetterPattern + '([ns]?)w-resize', 'gi'),\n    fourNotationQuantRegExp = new RegExp(fourNotationQuantPropsPattern + signedQuantPattern + '(\\\\s+)' + signedQuantPattern + '(\\\\s+)' + signedQuantPattern + '(\\\\s+)' + signedQuantPattern + suffixPattern, 'gi'),\n    fourNotationColorRegExp = new RegExp(fourNotationColorPropsPattern + colorPattern + '(\\\\s+)' + colorPattern + '(\\\\s+)' + colorPattern + '(\\\\s+)' + colorPattern + suffixPattern, 'gi'),\n    bgHorizontalPercentageRegExp = new RegExp('(background(?:-position)?\\\\s*:\\\\s*(?:[^:;}\\\\s]+\\\\s+)*?)(' + quantPattern + ')', 'gi'),\n    bgHorizontalPercentageXRegExp = new RegExp('(background-position-x\\\\s*:\\\\s*)(-?' + numPattern + '%)', 'gi'),\n    // border-radius: <length or percentage>{1,4} [optional: / <length or percentage>{1,4} ]\n    borderRadiusRegExp = new RegExp('(border-radius\\\\s*:\\\\s*)' + signedQuantPattern + '(?:(?:\\\\s+' + signedQuantPattern + ')(?:\\\\s+' + signedQuantPattern + ')?(?:\\\\s+' + signedQuantPattern + ')?)?' + '(?:(?:(?:\\\\s*\\\\/\\\\s*)' + signedQuantPattern + ')(?:\\\\s+' + signedQuantPattern + ')?(?:\\\\s+' + signedQuantPattern + ')?(?:\\\\s+' + signedQuantPattern + ')?)?' + suffixPattern, 'gi'),\n    boxShadowRegExp = new RegExp('(box-shadow\\\\s*:\\\\s*(?:inset\\\\s*)?)' + signedQuantPattern, 'gi'),\n    textShadow1RegExp = new RegExp('(text-shadow\\\\s*:\\\\s*)' + signedQuantPattern + '(\\\\s*)' + colorPattern, 'gi'),\n    textShadow2RegExp = new RegExp('(text-shadow\\\\s*:\\\\s*)' + colorPattern + '(\\\\s*)' + signedQuantPattern, 'gi'),\n    textShadow3RegExp = new RegExp('(text-shadow\\\\s*:\\\\s*)' + signedQuantPattern, 'gi'),\n    translateXRegExp = new RegExp('(transform\\\\s*:[^;}]*)(translateX\\\\s*\\\\(\\\\s*)' + signedQuantPattern + '(\\\\s*\\\\))', 'gi'),\n    translateRegExp = new RegExp('(transform\\\\s*:[^;}]*)(translate\\\\s*\\\\(\\\\s*)' + signedQuantPattern + '((?:\\\\s*,\\\\s*' + signedQuantPattern + '){0,2}\\\\s*\\\\))', 'gi');\n\n  /**\n   * Invert the horizontal value of a background position property.\n   *\n   * @private\n   * @param {string} match Matched property\n   * @param {string} pre Text before value\n   * @param {string} value Horizontal value\n   * @return {string} Inverted property\n   */\n  function calculateNewBackgroundPosition(match, pre, value) {\n    var idx, len;\n    if (value.slice(-1) === '%') {\n      idx = value.indexOf('.');\n      if (idx !== -1) {\n        // Two off, one for the \"%\" at the end, one for the dot itself\n        len = value.length - idx - 2;\n        value = 100 - parseFloat(value);\n        value = value.toFixed(len) + '%';\n      } else {\n        value = 100 - parseFloat(value) + '%';\n      }\n    }\n    return pre + value;\n  }\n\n  /**\n   * Invert a set of border radius values.\n   *\n   * @private\n   * @param {Array} values Matched values\n   * @return {string} Inverted values\n   */\n  function flipBorderRadiusValues(values) {\n    switch (values.length) {\n      case 4:\n        values = [values[1], values[0], values[3], values[2]];\n        break;\n      case 3:\n        values = [values[1], values[0], values[1], values[2]];\n        break;\n      case 2:\n        values = [values[1], values[0]];\n        break;\n      case 1:\n        values = [values[0]];\n        break;\n    }\n    return values.join(' ');\n  }\n\n  /**\n   * Invert a set of border radius values.\n   *\n   * @private\n   * @param {string} match Matched property\n   * @param {string} pre Text before value\n   * @param {string} [firstGroup1]\n   * @param {string} [firstGroup2]\n   * @param {string} [firstGroup3]\n   * @param {string} [firstGroup4]\n   * @param {string} [secondGroup1]\n   * @param {string} [secondGroup2]\n   * @param {string} [secondGroup3]\n   * @param {string} [secondGroup4]\n   * @param {string} [post] Text after value\n   * @return {string} Inverted property\n   */\n  function calculateNewBorderRadius(match, pre) {\n    var values,\n      args = [].slice.call(arguments),\n      firstGroup = args.slice(2, 6).filter(function (val) {\n        return val;\n      }),\n      secondGroup = args.slice(6, 10).filter(function (val) {\n        return val;\n      }),\n      post = args[10] || '';\n    if (secondGroup.length) {\n      values = flipBorderRadiusValues(firstGroup) + ' / ' + flipBorderRadiusValues(secondGroup);\n    } else {\n      values = flipBorderRadiusValues(firstGroup);\n    }\n    return pre + values + post;\n  }\n\n  /**\n   * Flip the sign of a CSS value, possibly with a unit.\n   *\n   * We can't just negate the value with unary minus due to the units.\n   *\n   * @private\n   * @param {string} value\n   * @return {string}\n   */\n  function flipSign(value) {\n    if (parseFloat(value) === 0) {\n      // Don't mangle zeroes\n      return value;\n    }\n    if (value[0] === '-') {\n      return value.slice(1);\n    }\n    return '-' + value;\n  }\n\n  /**\n   * @private\n   * @param {string} match\n   * @param {string} property\n   * @param {string} offset\n   * @return {string}\n   */\n  function calculateNewShadow(match, property, offset) {\n    return property + flipSign(offset);\n  }\n\n  /**\n   * @private\n   * @param {string} match\n   * @param {string} property\n   * @param {string} prefix\n   * @param {string} offset\n   * @param {string} suffix\n   * @return {string}\n   */\n  function calculateNewTranslate(match, property, prefix, offset, suffix) {\n    return property + prefix + flipSign(offset) + suffix;\n  }\n\n  /**\n   * @private\n   * @param {string} match\n   * @param {string} property\n   * @param {string} color\n   * @param {string} space\n   * @param {string} offset\n   * @return {string}\n   */\n  function calculateNewFourTextShadow(match, property, color, space, offset) {\n    return property + color + space + flipSign(offset);\n  }\n  return {\n    /**\n     * Transform a left-to-right stylesheet to right-to-left.\n     *\n     * @param {string} css Stylesheet to transform\n     * @param {Object} options Options\n     * @param {boolean} [options.transformDirInUrl=false] Transform directions in URLs\n     * (e.g. 'ltr', 'rtl')\n     * @param {boolean} [options.transformEdgeInUrl=false] Transform edges in URLs\n     * (e.g. 'left', 'right')\n     * @return {string} Transformed stylesheet\n     */\n    'transform': function (css, options) {\n      // eslint-disable-line quote-props\n      // Use single quotes in this object literal key for closure compiler.\n      // Tokenizers\n      var noFlipSingleTokenizer = new Tokenizer(noFlipSingleRegExp, noFlipSingleToken),\n        noFlipClassTokenizer = new Tokenizer(noFlipClassRegExp, noFlipClassToken),\n        commentTokenizer = new Tokenizer(commentRegExp, commentToken);\n\n      // Tokenize\n      css = commentTokenizer.tokenize(noFlipClassTokenizer.tokenize(noFlipSingleTokenizer.tokenize(\n      // We wrap tokens in ` , not ~ like the original implementation does.\n      // This was done because ` is not a legal character in CSS and can only\n      // occur in URLs, where we escape it to %60 before inserting our tokens.\n      css.replace('`', '%60'))));\n\n      // Transform URLs\n      if (options.transformDirInUrl) {\n        // Replace 'ltr' with 'rtl' and vice versa in background URLs\n        css = css.replace(ltrInUrlRegExp, '$1' + temporaryToken).replace(rtlInUrlRegExp, '$1ltr').replace(temporaryTokenRegExp, 'rtl');\n      }\n      if (options.transformEdgeInUrl) {\n        // Replace 'left' with 'right' and vice versa in background URLs\n        css = css.replace(leftInUrlRegExp, '$1' + temporaryToken).replace(rightInUrlRegExp, '$1left').replace(temporaryTokenRegExp, 'right');\n      }\n\n      // Transform rules\n      css = css\n      // Replace direction: ltr; with direction: rtl; and vice versa.\n      .replace(directionLtrRegExp, '$1' + temporaryToken).replace(directionRtlRegExp, '$1ltr').replace(temporaryTokenRegExp, 'rtl')\n      // Flip rules like left: , padding-right: , etc.\n      .replace(leftRegExp, '$1' + temporaryToken).replace(rightRegExp, '$1left').replace(temporaryTokenRegExp, 'right')\n      // Flip East and West in rules like cursor: nw-resize;\n      .replace(cursorEastRegExp, '$1$2' + temporaryToken).replace(cursorWestRegExp, '$1$2e-resize').replace(temporaryTokenRegExp, 'w-resize')\n      // Border radius\n      .replace(borderRadiusRegExp, calculateNewBorderRadius)\n      // Shadows\n      .replace(boxShadowRegExp, calculateNewShadow).replace(textShadow1RegExp, calculateNewFourTextShadow).replace(textShadow2RegExp, calculateNewFourTextShadow).replace(textShadow3RegExp, calculateNewShadow)\n      // Translate\n      .replace(translateXRegExp, calculateNewTranslate).replace(translateRegExp, calculateNewTranslate)\n      // Swap the second and fourth parts in four-part notation rules\n      // like padding: 1px 2px 3px 4px;\n      .replace(fourNotationQuantRegExp, '$1$2$3$8$5$6$7$4$9').replace(fourNotationColorRegExp, '$1$2$3$8$5$6$7$4$9')\n      // Flip horizontal background percentages\n      .replace(bgHorizontalPercentageRegExp, calculateNewBackgroundPosition).replace(bgHorizontalPercentageXRegExp, calculateNewBackgroundPosition);\n\n      // Detokenize\n      css = noFlipSingleTokenizer.detokenize(noFlipClassTokenizer.detokenize(commentTokenizer.detokenize(css)));\n      return css;\n    }\n  };\n}\n\n/* Initialization */\n\ncssjanus = new CSSJanus();\n\n/* Exports */\n\nif (typeof module !== 'undefined' && module.exports) {\n  /**\n   * Transform a left-to-right stylesheet to right-to-left.\n   *\n   * This function is a static wrapper around the transform method of an instance of CSSJanus.\n   *\n   * @param {string} css Stylesheet to transform\n   * @param {Object|boolean} [options] Options object, or transformDirInUrl option (back-compat)\n   * @param {boolean} [options.transformDirInUrl=false] Transform directions in URLs\n   * (e.g. 'ltr', 'rtl')\n   * @param {boolean} [options.transformEdgeInUrl=false] Transform edges in URLs\n   * (e.g. 'left', 'right')\n   * @param {boolean} [transformEdgeInUrl] Back-compat parameter\n   * @return {string} Transformed stylesheet\n   */\n  exports.transform = function (css, options, transformEdgeInUrl) {\n    var norm;\n    if (typeof options === 'object') {\n      norm = options;\n    } else {\n      norm = {};\n      if (typeof options === 'boolean') {\n        norm.transformDirInUrl = options;\n      }\n      if (typeof transformEdgeInUrl === 'boolean') {\n        norm.transformEdgeInUrl = transformEdgeInUrl;\n      }\n    }\n    return cssjanus.transform(css, norm);\n  };\n} else if (typeof window !== 'undefined') {\n  /* global window */\n  // Allow cssjanus to be used in a browser.\n  // eslint-disable-next-line dot-notation\n  window['cssjanus'] = cssjanus;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}